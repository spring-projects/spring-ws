<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="tutorial">
    <title>Writing Contract-First Web Services</title>
    <section>
        <title>Introduction</title>
        <para>
            This tutorial shows you how to write
            <link linkend="why-contract-first">contract-first Web services</link>, that is,
            developing web services that start with the XML Schema/WSDL contract first
            followed by the Java code second. Spring-WS focuses on this development style,
            and this tutorial will help you get started. Note that the first part of this
            tutorial contains almost no Spring-WS specific information: it is mostly about
            XML, XSD, and WSDL. The <link linkend="tutorial-creating-project">second part</link>
            focuses on implementing this contract using Spring-WS .
        </para>
        <para>
            The most important thing when doing contract-first Web service development is
            to try and think in terms of XML. This means that Java-language concepts are
            of lesser importance. It is the XML that is sent across the wire, and you
            should focus on that. The fact that Java is used to implement the Web service
            is an implementation detail. An important detail, but a detail nonetheless.
        </para>
        <para>
            In this tutorial, we will define a Web service that is created by a Human Resources
            department. Clients can send holiday request forms to this service to book a holiday.
        </para>
    </section>
    <section>
        <title>Messages</title>
        <para>
            In this section, we will focus on the actual XML messages that are sent to
            and from the Web service. We will start out by determining what these messages
            look like.
        </para>
        <section>
            <title>Holiday</title>
            <para>
                In the scenario, we have to deal with holiday requests, so it makes sense
                to determine what a holiday looks like in XML:
            </para>
            <programlisting><![CDATA[
<Holiday xmlns="http://mycompany.com/hr/schemas">
    <StartDate>2006-07-03</StartDate>
    <EndDate>2006-07-07</EndDate>
</Holiday>]]></programlisting>
            <para>
                A holiday consists of a start date and an end date. We have also decided to
                use the standard
                <ulink url="http://www.cl.cam.ac.uk/~mgk25/iso-time.html">ISO 8601</ulink>
                date format for the dates, because that will save a lot of parsing hassle.
                We have also added a namespace to the element, to make sure our elements
                can used within other XML documents.
            </para>
        </section>
        <section>
            <title>Employee</title>
            <para>
                There is also the notion of an employee in the scenario. Here is what it
                looks like in XML:
            </para>
            <programlisting><![CDATA[
<Employee xmlns="http://mycompany.com/hr/schemas">
    <Number>42</Number>
    <FirstName>Arjen</FirstName>
    <LastName>Poutsma</LastName>
</Employee>]]></programlisting>
            <para>
                We have used the same namespace as before. If this
                <literal>&lt;Employee/&gt;</literal> element could be used in other
                scenarios, it might make sense to use a different namespace, such as
                <literal>http://mycompany.com/employees/schemas</literal>.
            </para>
        </section>
        <section>
            <title>HolidayRequest</title>
            <para>
                Both the holiday and employee element can be put in a
                <literal>&lt;HolidayRequest/&gt;</literal>:
            </para>
            <programlisting><![CDATA[
<HolidayRequest xmlns="http://mycompany.com/hr/schemas">
    <Holiday>
        <StartDate>2006-07-03</StartDate>
        <EndDate>2006-07-07</EndDate>
    </Holiday>
    <Employee>
        <Number>42</Number>
        <FirstName>Arjen</FirstName>
        <LastName>Poutsma</LastName>
    </Employee>
</HolidayRequest>]]></programlisting>
            <para>
                The order of the two elements does not matter: <literal>&lt;Employee/&gt;</literal>
                could have been the first element just as well. What is important is
                that all of the data is there. In fact, the data is the only thing
                that is important: we are taking a <emphasis>data-driven</emphasis>
                approach.
            </para>
        </section>
    </section>
    <section id="tutorial.xsd">
        <title>Data Contract</title>
        <para>
            Now that we have seen some examples of the XML data that we will use,
            it makes sense to formalize this into a schema. This data contract
            defines the message format we accept. There are four different ways
            of defining such a contract for XML:
        </para>
        <itemizedlist>
            <listitem><para>DTDs</para></listitem>
            <listitem><para><ulink url="http://www.w3.org/XML/Schema">XML Schema (XSD)</ulink></para></listitem>
            <listitem><para><ulink url="http://www.relaxng.org/">RELAX NG</ulink></para></listitem>
            <listitem><para><ulink url="http://www.schematron.com/">Schematron</ulink></para></listitem>
        </itemizedlist>
        <para>
            DTDs have limited namespace support, so they are not suitable for Web
            services. Relax NG and Schematron certainly are easier than XML Schema.
            Unfortunately, they are not so widely supported across platforms. We
            will use XML Schema.
        </para>
        <para>
            By far the easiest way to create an XSD is to infer it from sample
            documents. Any good XML editor or Java IDE offers this functionality.
            Basically, these tools use some sample XML documents, and generate a
            schema from it that validates them all. The end result certainly needs
            to be polished up, but it's a great starting point.
        </para>
        <para>
            Using the sample described above, we end up with the following
            generated schema:
        </para>
        <programlisting><![CDATA[<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas"
        xmlns:hr="http://mycompany.com/hr/schemas">
    <xs:element name="HolidayRequest">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="hr:Holiday"/>
                <xs:element ref="hr:Employee"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="Holiday">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="hr:StartDate"/>
                <xs:element ref="hr:EndDate"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="StartDate" type="xs:NMTOKEN"/>
    <xs:element name="EndDate" type="xs:NMTOKEN"/>
    <xs:element name="Employee">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="hr:Number"/>
                <xs:element ref="hr:FirstName"/>
                <xs:element ref="hr:LastName"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="Number" type="xs:integer"/>
    <xs:element name="FirstName" type="xs:NCName"/>
    <xs:element name="LastName" type="xs:NCName"/>
</xs:schema>]]></programlisting>
        <para>
            This generated schema obviously can be improved. The first thing
            to notice is that every type has a root-level element declaration.
            This means that the Web service should be able to accept all of
            these elements as data. This is not desirable: we only want to
            accept a <literal>&lt;HolidayRequest/&gt;</literal>. By removing
            the wrapping element tags (thus keeping the types), and inlining
            the results, we can accomplish this.
        </para>
        <programlisting><![CDATA[<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas">
    <xs:element name="HolidayRequest">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Holiday" type="hr:HolidayType"/>
                <xs:element name="Employee" type="hr:EmployeeType"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="HolidayType">
        <xs:sequence>
            <xs:element name="StartDate" type="xs:NMTOKEN"/>
            <xs:element name="EndDate" type="xs:NMTOKEN"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="EmployeeType">
        <xs:sequence>
            <xs:element name="Number" type="xs:integer"/>
            <xs:element name="FirstName" type="xs:NCName"/>
            <xs:element name="LastName" type="xs:NCName"/>
        </xs:sequence>
    </xs:complexType>
</xs:schema>]]></programlisting>
        <para>
            The schema still has one problem: with a schema like this, you
            can expect the following messages to validate:
        </para>
        <programlisting>
<![CDATA[<HolidayRequest xmlns="http://mycompany.com/hr/schemas">
    <Holiday>
        <StartDate>this is not a date</StartDate>
        <EndDate>neither is this</EndDate>
    </Holiday>
    ]]><lineannotation>&lt;!-- ... --&gt;</lineannotation><![CDATA[
</HolidayRequest>]]></programlisting>
        <para>
            Clearly, we must make sure that the start and end date are really dates.
            XML Schema has an excellent built-in <literal>date</literal> type which
            we can use. We also change the <literal>NCName</literal>s to
            <literal>string</literal>s. Finally, we change the <literal>sequence</literal> in
            <literal>&lt;HolidayRequest/&gt;</literal> to <literal>all</literal>.
            This tells the XML parser that the order of
            <literal>&lt;Holiday/&gt;</literal> and
            <literal>&lt;Employee/&gt;</literal> is not significant. Our final
            XSD now looks like this:
        </para>
        <programlistingco>
            <areaspec>
                <area id="tutorial.xsd.all" coords="8"/>
                <areaset id="tutorial.xsd.dates" coords="">
                    <area id="tutorial.xsd.dates.1" coords="16"/>
                    <area id="tutorial.xsd.dates.2" coords="17"/>
                </areaset>
                <areaset id="tutorial.xsd.strings" coords="">
                    <area id="tutorial.xsd.strings.1" coords="23"/>
                    <area id="tutorial.xsd.strings.2" coords="24"/>
                </areaset>
            </areaspec>
            <programlisting><![CDATA[<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:hr="http://mycompany.com/hr/schemas"
        elementFormDefault="qualified"
        targetNamespace="http://mycompany.com/hr/schemas">
    <xs:element name="HolidayRequest">
        <xs:complexType>
            <xs:all>
                <xs:element name="Holiday" type="hr:HolidayType"/>
                <xs:element name="Employee" type="hr:EmployeeType"/>
            </xs:all>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="HolidayType">
        <xs:sequence>
            <xs:element name="StartDate" type="xs:date"/>
            <xs:element name="EndDate" type="xs:date"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="EmployeeType">
        <xs:sequence>
            <xs:element name="Number" type="xs:integer"/>
            <xs:element name="FirstName" type="xs:string"/>
            <xs:element name="LastName" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
</xs:schema>]]></programlisting>
            <calloutlist>
                <callout arearefs="tutorial.xsd.all">
                    <para>
                        <literal>all</literal> tells the XML parser that the order of
                        <literal>&lt;Holiday/&gt;</literal> and
                        <literal>&lt;Employee/&gt;</literal> is not significant.
                    </para>
                </callout>
                <callout arearefs="tutorial.xsd.dates">
                    <para>
                        We use the <literal>xsd:date</literal> data type, which consist of a year, month, and day, for
                        <literal>&lt;StartDate/&gt;</literal> and <literal>&lt;EndDate/&gt;</literal>.
                    </para>
                </callout>
                <callout arearefs="tutorial.xsd.strings">
                    <para>
                        <literal>xsd:string</literal> is used for the first and last name.
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>
        <para>
            We store this file as <filename>hr.xsd</filename>.
        </para>
    </section>
    <section id="tutorial-service-contract">
        <title>Service contract</title>
        <para>
            A service contract is generally expressed as a <ulink url="http://www.w3.org/TR/wsdl">WSDL</ulink> file.
            Note that in Spring-WS, <emphasis>writing the WSDL by hand is not required</emphasis>. Based on the XSD and
            some conventions, Spring-WS can create the WSDL for you, as explained in the section entitled
            <xref linkend="tutorial.implementing.endpoint"/>.
            You can skip to <link linkend="tutorial-creating-project">the next section</link> if you want to; the
            remainder of this section will show you how to write your own WSDL by hand.
         </para>
         <para>
            We start our WSDL with the standard preamble, and by importing our existing XSD. To
            separate the schema from the definition, we will use a separate namespace for the WSDL definitions:
            <uri>http://mycompany.com/hr/definitions</uri>.
        </para>
        <programlisting><![CDATA[<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions">
    <wsdl:types>
        <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:import namespace="http://mycompany.com/hr/schemas" schemaLocation="hr.xsd"/>
        </xsd:schema>
    </wsdl:types>]]></programlisting>
        <para>
            Next, we add our messages based on the written schema types. We only have one message: one with the
            <literal>&lt;HolidayRequest/&gt;</literal> we put in the schema:
        </para>
        <programlisting><![CDATA[
    <wsdl:message name="HolidayRequest">
        <wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/>
    </wsdl:message>]]></programlisting>
        <para>
            We add the message to a port type as an operation:
        </para>
        <programlisting><![CDATA[
    <wsdl:portType name="HumanResource">
        <wsdl:operation name="Holiday">
            <wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/>
        </wsdl:operation>
    </wsdl:portType>]]></programlisting>
        <para>
            That finished the abstract part of the WSDL (the interface, as it were), and leaves the concrete part.
            The concrete part consists of a <literal>binding</literal>, which tells the client <emphasis>how</emphasis>
            to invoke the operations you've just defined; and a <literal>service</literal>, which tells it
            <emphasis>where</emphasis> to invoke it.
        </para>
        <para>
            Adding a concrete part is pretty standard: just refer to the abstract part you defined previously, make sure
            you use <emphasis>document/literal</emphasis> for the <literal>soap:binding</literal> elements
            (<literal>rpc/encoded</literal> is deprecated), pick a <literal>soapAction</literal> for the operation
            (in this case <uri>http://mycompany.com/RequestHoliday</uri>, but any URI will do), and determine the
            <literal>location</literal> URL where you want request to come in (in this case
            <uri>http://mycompany.com/humanresources</uri>):
        </para>
        <programlistingco>
            <areaspec>
                <area id="tutorial.wsdl.import" coords="9"/>
                <areaset id="tutorial.wsdl.message" coords="">
                    <area id="tutorial.wsdl.message.def" coords="13"/>
                    <area id="tutorial.wsdl.message.ref" coords="18"/>
                </areaset>
                <area id="tutorial.wsdl.message.part" coords="14"/>
                <areaset id="tutorial.wsdl.portType" coords="">
                    <area id="tutorial.wsdl.portType.def" coords="16"/>
                    <area id="tutorial.wsdl.portType.ref" coords="21"/>
                </areaset>
                <areaset id="tutorial.wsdl.binding" coords="">
                    <area id="tutorial.wsdl.binding.def" coords="21"/>
                    <area id="tutorial.wsdl.binding.ref" coords="32"/>
                </areaset>
                <areaset id="tutorial.wsdl.doclit" coords="">
                    <area id="tutorial.wsdl.doclit.doc" coords="22"/>
                    <area id="tutorial.wsdl.doclit.lit" coords="27"/>
                </areaset>
                <area id="tutorial.wsdl.transport" coords="23"/>
                <area id="tutorial.wsdl.soapAction" coords="25"/>
                <area id="tutorial.wsdl.address" coords="33"/>
            </areaspec>
            <programlisting><![CDATA[
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  xmlns:schema="http://mycompany.com/hr/schemas"
                  xmlns:tns="http://mycompany.com/hr/definitions"
                  targetNamespace="http://mycompany.com/hr/definitions">
    <wsdl:types>
        <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <xsd:import namespace="http://mycompany.com/hr/schemas"
                schemaLocation="hr.xsd"/>
        </xsd:schema>
    </wsdl:types>
    <wsdl:message name="HolidayRequest">
        <wsdl:part element="schema:HolidayRequest" name="HolidayRequest"/>
    </wsdl:message>
    <wsdl:portType name="HumanResource">
        <wsdl:operation name="Holiday">
            <wsdl:input message="tns:HolidayRequest" name="HolidayRequest"/>
        </wsdl:operation>
    </wsdl:portType>
    <wsdl:binding name="HumanResourceBinding" type="tns:HumanResource">
        <soap:binding style="document"
            transport="http://schemas.xmlsoap.org/soap/http"/>
        <wsdl:operation name="Holiday">
            <soap:operation soapAction="http://mycompany.com/RequestHoliday"/>
            <wsdl:input name="HolidayRequest">
                <soap:body use="literal"/>
            </wsdl:input>
        </wsdl:operation>
    </wsdl:binding>
    <wsdl:service name="HumanResourceService">
        <wsdl:port binding="tns:HumanResourceBinding" name="HumanResourcePort">
            <soap:address location="http://localhost:8080/holidayService/"/>
        </wsdl:port>
    </wsdl:service>
</wsdl:definitions>]]></programlisting>
            <calloutlist>
                <callout arearefs="tutorial.wsdl.import">
                    <para>
                        We import the schema defined in <xref linkend="tutorial.xsd"/>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.message">
                    <para>
                        We define the <literal>HolidayRequest</literal> message, which gets used in the
                        <literal>portType</literal>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.message.part">
                    <para>
                        The <literal>HolidayRequest</literal> type is defined in the schema.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.portType">
                    <para>
                        We define the <literal>HumanResource</literal> port type, which gets used in the
                        <literal>binding</literal>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.binding">
                    <para>
                        We define the <literal>HumanResourceBinding</literal> binding, which gets used in the
                        <literal>port</literal>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.doclit">
                    <para>
                        We use a document/literal style.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.transport">
                    <para>
                        The literal <uri>http://schemas.xmlsoap.org/soap/http</uri> signifies a
                        HTTP transport.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.soapAction">
                    <para>
                        The <literal>soapAction</literal> attribute signifies the <literal>SOAPAction</literal> HTTP
                        header that will be sent with every request.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.address">
                    <para>
                        The <uri>http://localhost:8080/holidayService/</uri> address is the URL where the Web
                        service can be invoked.
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>
        <para>
            This is the final WSDL. We will describe how to implement the resulting schema and WSDL in the next section.
        </para>
    </section>
    <section id="tutorial-creating-project">
        <title>Creating the project</title>
        <para>
            In this section, we will be using <ulink url="http://maven.apache.org/">Maven3</ulink> to create the
            initial project structure for us. Doing so is not required, but greatly reduces the amount of code we
            have to write to setup our HolidayService.
        </para>
        <para>
            The following command creates a Maven3 web application project for us, using the Spring-WS archetype
            (that is, project template)
        </para>
<screen>mvn archetype:create -DarchetypeGroupId=org.springframework.ws \
  -DarchetypeArtifactId=spring-ws-archetype \
  -DarchetypeVersion=<?eval ${project.version}?> \
  -DgroupId=com.mycompany.hr \
  -DartifactId=holidayService
</screen>
        <para>
            This command will create a new directory called <filename>holidayService</filename>. In this directory,
            there is a <filename>'src/main/webapp'</filename> directory, which will contain the root of the WAR file.
            You will find the standard web application deployment descriptor <filename>'WEB-INF/web.xml'</filename>
            here, which defines a Spring-WS <classname>MessageDispatcherServlet</classname> and maps all incoming
            requests to this servlet.
        </para>
        <programlisting><![CDATA[
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
             http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4">

    <display-name>MyCompany HR Holiday Service</display-name>

    ]]><lineannotation>&lt;!-- take especial notice of the name of this servlet --&gt;</lineannotation><![CDATA[
    <servlet>
        <servlet-name>]]><lineannotation><emphasis role="bold">spring-ws</emphasis></lineannotation><![CDATA[</servlet-name>
        <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>spring-ws</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>

</web-app>]]></programlisting>
        <para>
            In addition to the above <filename>'WEB-INF/web.xml'</filename> file, you will also need another,
            Spring-WS-specific configuration file, named <filename>'WEB-INF/spring-ws-servlet.xml'</filename>.
            This file contains all of the Spring-WS-specific beans such as <literal>EndPoints</literal>,
            <literal>WebServiceMessageReceivers</literal>, and suchlike, and is used to create a new Spring container.
            The name of this file is derived from the name of the attendant servlet (in this case
            <literal>'spring-ws'</literal>) with <literal>'-servlet.xml'</literal> appended to it.
            So if you defined a <classname>MessageDispatcherServlet</classname> with the name
            <literal>'dynamite'</literal>, the name of the Spring-WS-specific configuration file would be
            <filename>'WEB-INF/dynamite-servlet.xml'</filename>.
        </para>
        <para>
            (You can see the contents of the <filename>'WEB-INF/spring-ws-servlet.xml'</filename> file for this
            example in <xref linkend="tutorial.example.sws-conf-file"/>.)
        </para>
        <para>
            Once you had the project structure created, you can put the schema and wsdl from previous section into
            <filename>'WEB-INF/'</filename> folder.
        </para>
    </section>
    <section id="tutorial.implementing.endpoint">
        <title>Implementing the Endpoint</title>
        <para>
           In Spring-WS, you will implement <emphasis>Endpoints</emphasis> to handle incoming XML messages.
           An endpoint is typically created by annotating a class with the <interfacename>@Endpoint</interfacename>
           annotation.
           In this endpoint class, you will create one or more methods that handle incoming request.
           The method signatures can be quite flexible: you can include just about any sort of parameter type related
           to the incoming XML message, as will be explained later.
        </para>
        <section>
            <title>Handling the XML Message</title>
            <para>
                In this sample application, we are going to use <ulink url="http://www.jdom.org">JDom</ulink> to handle
                the XML message.
                We are also using <ulink url="http://www.w3schools.com/xpath/">XPath</ulink>, because it allows us to
                select particular parts of the XML JDOM tree, without requiring strict schema conformance.
            </para>
            <programlistingco>
                <areaspec>
                    <area id="tutorial.endpoint.atEndpoint" coords="17"/>
                    <area id="tutorial.endpoint.constr" coords="31"/>
                    <area id="tutorial.endpoint.payloadRoot" coords="47"/>
                    <area id="tutorial.endpoint.method" coords="48"/>
                </areaspec>
                <programlisting><![CDATA[package com.mycompany.hr.ws;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;

import com.mycompany.hr.service.HumanResourceService;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.Namespace;
import org.jdom.xpath.XPath;

@Endpoint
public class HolidayEndpoint {

  private static final String NAMESPACE_URI = "http://mycompany.com/hr/schemas";

  private XPath startDateExpression;

  private XPath endDateExpression;

  private XPath nameExpression;

  private HumanResourceService humanResourceService;

  @Autowired
  public HolidayEndpoint(HumanResourceService humanResourceService)
      throws JDOMException {
    this.humanResourceService = humanResourceService;

    Namespace namespace = Namespace.getNamespace("hr", NAMESPACE_URI);

    startDateExpression = XPath.newInstance("//hr:StartDate");
    startDateExpression.addNamespace(namespace);

    endDateExpression = XPath.newInstance("//hr:EndDate");
    endDateExpression.addNamespace(namespace);

    nameExpression = XPath.newInstance("concat(//hr:FirstName,' ',//hr:LastName)");
    nameExpression.addNamespace(namespace);
  }

  @PayloadRoot(namespace = NAMESPACE_URI, localPart = "HolidayRequest")
  public void handleHolidayRequest(@RequestPayload Element holidayRequest)
      throws Exception {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date startDate = dateFormat.parse(startDateExpression.valueOf(holidayRequest));
    Date endDate = dateFormat.parse(endDateExpression.valueOf(holidayRequest));
    String name = nameExpression.valueOf(holidayRequest);

    humanResourceService.bookHoliday(startDate, endDate, name);
  }

}]]></programlisting>
                <calloutlist>
                    <callout arearefs="tutorial.endpoint.atEndpoint">
                        <para>
                            The <classname>HolidayEndpoint</classname> is annotated with
                            <interfacename>@Endpoint</interfacename>.
                            This marks the class as a special sort of <interfacename>@Component</interfacename>,
                            suitable for handling XML messages in Spring-WS, and also making it eligible for suitable
                            for component scanning.
                        </para>
                    </callout>
                    <callout arearefs="tutorial.endpoint.constr">
                        <para>
                            The <classname>HolidayEndpoint</classname> requires the
                            <interfacename>HumanResourceService</interfacename> business service to operate, so we
                            inject the dependency via the constructor and annotate it with
                            <interfacename>@Autowired</interfacename>.
                            Next, we set up XPath expressions using the JDOM API.
                            There are three expressions: <literal>//hr:StartDate</literal> for
                            extracting the <literal>&lt;StartDate&gt;</literal> text value,
                            <literal>//hr:EndDate</literal> for
                            extracting the end date and <literal>concat(//hr:FirstName,' ',//hr:LastName)</literal>
                            for extracting and concatenating the names of the employee.
                        </para>
                    </callout>
                    <callout arearefs="tutorial.endpoint.payloadRoot">
                        <para>
                            The <interfacename>@PayloadRoot</interfacename> annotation tells Spring-WS that the
                            <methodname>handleHolidayRequest</methodname> method is suitable for handling XML messages.
                            The sort of message that this method can handle is indicated by the annotation values,
                            in this case, it can handle XML elements that have the <literal>HolidayRequest</literal>
                            local part and the <literal>http://mycompany.com/hr/schemas</literal> namespace.
                            More information about mapping messages to endpoints is provided in the next section.
                        </para>
                    </callout>
                    <callout arearefs="tutorial.endpoint.method">
                        <para>
                            The <methodname>handleHolidayRequest(..)</methodname> method is the main handling method
                            method, which gets passed with the <literal>&lt;HolidayRequest/&gt;</literal> element from
                            the incoming XML message.
                            The <interfacename>@RequestPayload</interfacename> annotation indicates that the
                            <parameter>holidayRequest</parameter> parameter should be mapped to the payload of the
                            request message.
                            We use the XPath expressions to extract the string values from the XML messages,
                            and convert these values to <classname>Date</classname> objects using a
                            <classname>SimpleDateFormat</classname>.
                            With these values, we invoke a method on the business service.
                            Typically, this will result in a database transaction being started, and some records being
                            altered in the database.
                            Finally, we define a <literal>void</literal> return type, which indicates to Spring-WS
                            that we do not want to send a response message.
                            If we wanted a response message, we could have returned a JDOM Element
                            that represents the payload of the response message.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                 Using JDOM is just one of the options to handle the XML: other options include DOM, dom4j, XOM,
                 SAX, and StAX, but also marshalling techniques like JAXB, Castor, XMLBeans,
                 JiBX, and XStream, as is explained in the next chapter.
                 We chose JDOM because it gives us access to the raw XML, and because it
                 is based on classes (not interfaces and factory methods as with W3C DOM and dom4j), which makes the
                 code less verbose. We use XPath because it is less fragile than marshalling technologies: we don't
                 care for strict schema conformance, as long as we can find the dates and the name.
             </para>
             <para>
                 Because we use JDOM, we must add some dependencies to the Maven <filename>pom.xml</filename>, which is in the
                 root of our project directory. Here is the relevant section of the POM:
             </para>
             <programlisting>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.ws&lt;/groupId&gt;
        &lt;artifactId&gt;spring-ws-core&lt;/artifactId&gt;
        &lt;version&gt;<?eval ${project.version}?>&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jdom&lt;/groupId&gt;
        &lt;artifactId&gt;jdom&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;jaxen&lt;/groupId&gt;
        &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
             <para>
                Here is how we would configure these classes in our <filename>spring-ws-servlet.xml</filename>
                Spring XML configuration file, by using component scanning.
                We also instruct Spring-WS to use annotation-driven endpoints, with the
                <literal>&lt;sws:annotation-driven&gt;</literal> element.
            </para>
            <programlisting id="tutorial.example.sws-conf-file"><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:sws="http://www.springframework.org/schema/web-services"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/web-services http://www.springframework.org/schema/web-services/web-services-2.0.xsd
  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">

  <context:component-scan base-package="com.mycompany.hr"/>

  <sws:annotation-driven/>

</beans>]]></programlisting>
            </section>
            <section>
                <title>Routing the Message to the Endpoint</title>
                <para>
                    As part of writing the endpoint, we also used the <interfacename>@PayloadRoot</interfacename>
                    annotation to indicate which sort of messages can be handled by the
                    <methodname>handleHolidayRequest</methodname> method.
                    In Spring-WS, this process is the responsibility of an
                    <interfacename>EndpointMapping</interfacename>.
                    Here we route messages based on
                    their content, by using a <classname>PayloadRootAnnotationMethodEndpointMapping</classname>.
                    The annotation used above:<programlisting>
@PayloadRoot(namespace = "http://mycompany.com/hr/schemas", localPart = "HolidayRequest")</programlisting>
                    basically means that whenever an XML message is received with the namespace
                    <literal>http://mycompany.com/hr/schemas</literal> and the
                    <literal>HolidayRequest</literal> local name, it will be routed to the
                    <methodname>handleHolidayRequest</methodname> method.
                    By using the <literal>&lt;sws:annotation-driven&gt;</literal> element in our configuration, we
                    enable the detection of the <interfacename>@PayloadRoot</interfacename> annotations.
                    It is possible (and quite common) to have multiple, related handling methods in an endpoint, each
                    of them handling different XML messages.
                </para>
                <para>
                    There are also other ways to map endpoints to XML messages, which will be described in the next
                    chapter.
                </para>
            </section>
            <section>
                <title>Providing the Service and Stub implementation</title>
                <para>
                    Now that we have the <emphasis>Endpoint</emphasis>, we need 
                    <interfacename>HumanResourceService</interfacename> and its implementation for use by 
                    <classname>HolidayEndpoint</classname>.
                </para>
                <programlisting><![CDATA[package com.mycompany.hr.service;

import java.util.Date;

public interface HumanResourceService {
    void bookHoliday(Date startDate, Date endDate, String name);
}]]></programlisting>
                <para>
                    For tutorial purposes, we will use a simple stub implementation of the 
                    <interfacename>HumanResourceService</interfacename>.
                </para>
                <programlistingco>
                    <areaspec>
                      <aread id="tutorial.stubimpl.atService" coords="7"/>
                    </areaspec>
                    <programlisting><![CDATA[package com.mycompany.hr.service;

import java.util.Date;

import org.springframework.stereotype.Service;

@Service
public class StubHumanResourceService implements HumanResourceService {
    public void bookHoliday(Date startDate, Date endDate, String name) {
        System.out.println("Booking holiday for [" + startDate + "-" + endDate + "] for [" + name + "] ");
    }
}]]></programlisting>
                <calloutlist>
                    <callout arearefs="tutorial.stubimpl.atService">
                        <para>
                            The <classname>StubHumanResourceService</classname> is annotated with
                            <interfacename>@Service</interfacename>.
                            This marks the class as a business facade, which makes this a candidate for injection 
                            by <interfacename>@Autowired</interfacename> in <classname>HolidayEndpoint</classname>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </section>
    </section>
    <section id="tutorial-publishing-wsdl">
        <title>Publishing the WSDL</title>
        <para>
            Finally, we need to publish the WSDL. As stated in <xref linkend="tutorial-service-contract"/>, we don't
            need to write a WSDL ourselves; Spring-WS can generate one for us based on some conventions.
            Here is how we define the generation:
        </para>
        <programlistingco>
            <areaspec>
                <area id="tutorial.wsdl.gen.bean" coords="1"/>
                <area id="tutorial.wsdl.gen.schema" coords="5"/>
                <area id="tutorial.wsdl.gen.portType" coords="2"/>
                <area id="tutorial.wsdl.gen.locationUri" coords="3"/>
                <area id="tutorial.wsdl.gen.tns" coords="4"/>
            </areaspec>
            <programlisting><![CDATA[<sws:dynamic-wsdl id="holiday"
    portTypeName="HumanResource"
    locationUri="/holidayService/"
    targetNamespace="http://mycompany.com/hr/definitions">
  <sws:xsd location="/WEB-INF/hr.xsd"/>
</sws:dynamic-wsdl>]]></programlisting>
            <calloutlist>
                <callout arearefs="tutorial.wsdl.gen.bean">
                    <para>
                        The id determines the URL where the WSDL can be retrieved.
                        In this case, the id is <varname>holiday</varname>, which means that the WSDL can be retrieved
                        as <filename>holiday.wsdl</filename> in the servlet context.
                        The full URL will typically be <uri>http://localhost:8080/holidayService/holiday.wsdl</uri>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.gen.portType">
                    <para>
                        Next, we set the WSDL port type to be <literal>HumanResource</literal>.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.gen.locationUri">
                    <para>
                        We set the location where the service can be reached:
                        <uri>/holidayService/</uri>.
                        We use a relative URI and we instruct the framework to transform it
                        dynamically to an absolute URI.
                        Hence, if the service is deployed to different contexts we don't have
                        to change the URI manually.
                        For more information, please refer to <xref linkend="server-automatic-wsdl-exposure"/>
                    </para>
                    <para>
                        For the location transformation to work, we need to add an init parameter to <classname>spring-ws</classname>
                        servlet in <filename>web.xml</filename>:<programlisting><![CDATA[<init-param>
  <param-name>transformWsdlLocations</param-name>
  <param-value>true</param-value>
</init-param>]]></programlisting>
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.gen.tns">
                    <para>
                        We define the target namespace for the WSDL definition itself.
                        Setting this attribute is not required.
                        If not set, the WSDL will have the same namespace as the XSD schema.
                    </para>
                </callout>
                <callout arearefs="tutorial.wsdl.gen.schema">
                    <para>
                        The <varname>xsd</varname> element refers to the human resource schema we defined in
                        <xref linkend="tutorial.xsd"/>.
                        We simply placed the schema in the <filename>WEB-INF</filename> directory of the application.
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>
        <para>
            You can create a WAR file using <command>mvn install</command>.
            If you deploy the application (to Tomcat, Jetty, etc.), and point your browser at
            <ulink url="http://localhost:8080/holidayService/holiday.wsdl">this location</ulink>, you will
            see the generated WSDL. This WSDL is ready to be used by clients, such as
            <ulink url="http://www.soapui.org/">soapUI</ulink>, or other SOAP frameworks.
        </para>
    </section>
    <para>
        That concludes this tutorial. The tutorial code can be found in the full distribution of Spring-WS.
        The next step would be to look at the echo sample application that is part
        of the distribution. After that, look at the airline sample, which is a bit more complicated, because it
        uses JAXB, WS-Security, Hibernate, and a transactional service layer.
        Finally, you can read the rest of the reference documentation.
    </para>
</chapter>
